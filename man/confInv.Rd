% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{confInv}
\alias{confInv}
\title{Confidence interval for a proportion of variation, or heritability}
\usage{
confInv(
  y,
  X,
  lambda,
  range_h = as.numeric(c(0, 1)),
  tolerance = 1e-04,
  confLevel = 0.95,
  maxiter = 50L,
  type = "two-sided"
)
}
\arguments{
\item{y}{An vector of length n of observed responses.}

\item{X}{An n-by-p matrix of predictors, n > p.}

\item{lambda}{A vector of length n with (non-negative) variances, which are the
eigenvalues of the variance component covariance matrix (see details).}

\item{range_h}{A vector of length 2 giving the boundaries of the interval
within which the bisection search is performed. The endpoints must be in [0,1).}

\item{tolerance}{A positive scalar with the tolerance used in bisection search.}

\item{confLevel}{A number in (0, 1) with the level of the confidence interval.}

\item{maxiter}{A positive integer. Stop and warning if number of iterations
in search exceeds this value.}

\item{type}{A string that is either "two-sided", "lower_bd" (lower bound only)
or "upper_bd" (upper bound only) CI needs to be calculated. Default is "two-sided".}
}
\value{
A vector of length 2 with endpoints of the confidence interval. NA if no root found.
}
\description{
Calculate a confidence interval by numerically inverting the test-statistic
implemented in the function \code{varRatioTest1d}. Numerical inversion is done by
bisection search for points where the graph of the test-statistic as a function
of the null-hypothesis value \code{h2} crosses the appropriate quantile.
}
\details{
The function assumes the model
\deqn{y \sim N(X \beta, \sigma_g^2 \Lambda + \sigma_e^2 I_n),}
where \eqn{\Lambda} is a diagonal matrix with non-negative diagonal elements
supplied in the argument vector \code{lambda}. See the documentation for
\code{varRatioTest1d} for how this model often results from transforming more
common ones using an eigendecomposition.

The parameter of interest is \eqm{h^2 = \sigma^2_g / (\sigma^2_g + \sigma^2_e).}

If the parameter of interest is instead \eqn{\tau = \sigma^2_g/\sigma^2_e},
note \eqn{h^2 = \tau / (1 + \tau)}. Therefore, after running the function
to compute interval endpoints \code{a < b} for \eqn{h^2}, a confidence interval for \eqn{\tau}
has lower endpoint \code{a/(1 - a)} and upper endpoint \code{b / (1 - b)}.
}
