# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Restricted score test-statistic for a proportion of variation, or heritability
#'
#' @description
#' Compute a restricted score test statistic for the proportion of variation due to the
#' variance component in a model with one variance component and an error term.
#' The function assumes the covariance matrix corresponding to the variance component is
#' diagonal which in practice usually means the actual covariance matrix
#' has been eigendecomposed and the transformed data are supplied to this
#' function (see details). This proportion is known as heritability in some
#' applications, and therefore denoted `h2` in the code.
#'
#' @param h2 The null hypothesis value, which needs to be in [0,1).
#' @param y An vector of length n of observed responses.
#' @param X An n-by-p matrix of predictors, n > p.
#' @param lambda A vector of length n with (non-negative) variances, which are the
#' eigenvalues of the variance component covariance matrix (see details).
#' @return The test-statistic evaluated at `h2`.
#'
#' @details
#' The function assumes the model
#' \deqn{y \sim N(X \beta, \sigma_g^2 K + \sigma_e^2 I_n),}
#' where \eqn{K} is a positive semi-definite (covariance) matrix with
#' eigendecomposition \eqn{U\Lambda U^\top}.
#' The parameter of interest is \eqn{h^2=\sigma_g^2/(\sigma^2_g + \sigma^2_e)}.
#' The argument `y` should be \eqn{U^\top y}, the argument `X` is \eqn{U^\top X},
#' and the argument `lambda` a vector of the diagonal elements of \eqn{\Lambda}.
#' The test statistic is approximately chi-square with one degree of
#' freedom, even if `h2` is small or equal to zero.
#'
#' If the parameter of interest is instead \eqn{\tau = \sigma^2_g/\sigma^2_e},
#' note \eqn{h^2 = \tau / (1 + \tau)}, so the function can be evaluated the
#' null hypothesis value for \eqn{\tau}, say `tau`, by calling
#' `varRatioTest1d(h2 = tau / (1 + tau), ...)`.
#'
#' @export
varRatioTest1d <- function(h2, y, X, lambda) {
    .Call(`_lmmvar_varRatioTest1d`, h2, y, X, lambda)
}

#' 2d score test statistics for proportion of variation and total variation
#'
#' @description
#' compute the score test statistic for (h2, s2p), where s2p is the total variationin a linear mixed model;
#' h2 is the proportion of variation of indepedent random component versus the total variation,
#' assuming the covariance matrix corresponding to the random component is diagonal (see details).
#'
#' @param h2 an numeric indicates the desired value of proportion of variation that need to be tested. Needs to be within [0,1).
#' @param s2p an positive numeric indicates the desired value of total variation that need to be tested.
#' @param y An n-vector of observed responses.
#' @param X An n times p matrix of predictors, n > p.
#' @param lambda An n-vector of values in the diagonal matrix Lambda. Values need to be non-negative.
#' @return A single value showing the score test statistics
#'
#' @details
#' Assuming the linear mixed model follows y ~ N(X\% beta, \% sigma_g \% Lambda + \% sigma_e I).
#' The proportion of variation of indepedent random component, h2, is \% sigma_g / (\% sigma_g+\% sigma_e),
#' the total variation \% sigma_p = \% sigma_g+\% sigma_e, then y can also be seen to follow N(X\% beta, \% sigma_p(h2\% Lambda + (1-h2)I)).
#' \% Lambda is a diagonal matrix which can be achieved by applying eigen decomposition to your non-diagonal SPD \% Lambda as well as X and y.
#' By the nature of the model, the support set of h2 has to be in [0,1). The test statistic follows \% Chi(2).
#'
#' @export
varRatioTest2d <- function(h2, s2p, y, X, lambda) {
    .Call(`_lmmvar_varRatioTest2d`, h2, s2p, y, X, lambda)
}

#' find confidence interval for h2
#'
#' @description
#' calculating confidence interval for h2,
#' which is the proportion of variation of indepedent random component versus the total variation in a linear mixed model.
#' Using Ternary search for finding the minimum, and binary search for finding roots.
#'
#' @param range_h A vector of length 2 giving the boundary of range in which to apply searching algorithms. Needs to be within [0,1).
#' @param y A n\%*1 vector of observed responses
#' @param X A n\%*p predictors matrix, n > p
#' @param lambda A n\%*1 vector represent values in the diagonal matrix Lambda. Values need to be non-negative.
#' @param tolerance A positive numeric. Differences smaller than tolerance are considered to be equal.
#' @param confLevel A numeric within [0,1]. Confidence level.
#' @return A vector of length 2 showing confidence interval. NA if no root found.
#' @details Assuming the linear mixed model follows y ~ N(X\% beta, \% sigma_g \% Lambda + \% sigma_e I).
#' The proportion of variation of indepedent random component, h2, is \% sigma_g / (\% sigma_g+\% sigma_e),
#' the total variation \% sigma_p = \% sigma_g+\% sigma_e, then y can also be seen to follow N(X\% beta, \% sigma_p(h2\% Lambda + (1-h2)I)).
#' \% Lambda is a diagonal matrix which can be achieved by applying eigen decomposition to your non-diagonal SPD \% Lambda as well as X and y.
#' By the nature of the model, the support set of h2 has to be in [0,1), and we assuming the test statistics forms a quasi-convex trend.
#' @export
confInv <- function(range_h, y, X, lambda, tolerance = 1e-4, confLevel = 0.95) {
    .Call(`_lmmvar_confInv`, range_h, y, X, lambda, tolerance, confLevel)
}

#' 2d score test statistics matrix for a range of proportion of variation and total variation
#'
#' @description
#' for a range of h2 and s2p, compute the score test statistic at grid \%* grid different pair of values, where s2p is the total variationin a linear mixed model;
#' h2 is the proportion of variation of independent random component versus the total variation,
#' assuming the covariance matrix corresponding to the random component is diagonal (see details).
#'
#' @param range_h A vector of length 2 giving the boundary of range of h2 which are partitioned into grid different values. Range needs to be within [0,1).
#' @param range_p A vector of length 2 giving the boundary of range of h2 which are partitioned into grid different values.
#' @param y A n\%*1 vector of observed responses.
#' @param X A n\%*p predictors matrix, n > p.
#' @param lambda A n\%*1 vector represent values in the diagonal matrix Lambda. Values need to be non-negative.
#' @param grid An integer indicates how many different values within the range need to be tested.
#' @return A matrix showing the score test statistics.
#' @details
#' Assuming the linear mixed model follows y ~ N(X\% beta, \% sigma_g \% Lambda + \% sigma_e I).
#' The proportion of variation of indepedent random component, h2, is \% sigma_g / (\% sigma_g+\% sigma_e),
#' the total variation \% sigma_p = \% sigma_g+\% sigma_e, then y can also be seen to follow N(X\% beta, \% sigma_p(h2\% Lambda + (1-h2)I)).
#' \% Lambda is a diagonal matrix which can be achieved by applying eigen decomposition to your non-diagonal SPD \% Lambda as well as X and y.
#' By the nature of the model, the support set of h2 has to be in [0,1), and the support set of h2 has to be positive.
#' @export
confReg <- function(range_h, range_p, y, X, lambda, grid = 200L) {
    .Call(`_lmmvar_confReg`, range_h, range_p, y, X, lambda, grid)
}

